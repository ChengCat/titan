/* This file was generated by the Titan compiler. Do not edit by hand */
/* Indentation and formatting courtesy of titan-compiler/pretty.lua */

#include <string.h>

#include "tcore.h"

#include "lua.h"
#include "lauxlib.h"
#include "lualib.h"

#include "lapi.h"
#include "lfunc.h"
#include "lgc.h"
#include "lobject.h"
#include "lstate.h"
#include "lstring.h"
#include "ltable.h"
#include "lvm.h"

#include "math.h"

#include <assert.h>

static lua_Number function_matmul_titan(
    lua_State * L,
    Table * x1 /* A */,
    Table * x2 /* B */
){
    {
        lua_Number x3 /* s */ = 0x0p+0 /*0.000000*/;
        lua_Integer x4 = luaH_getn(x1);
        lua_Integer x5 /* NI */ = x4;
        lua_Integer x6 = luaH_getn(x2);
        lua_Integer x7 /* NK */ = x6;
        lua_Unsigned x8 /* ui */ = ((lua_Unsigned)1) - 1;
        const TValue * x9 /* arrslot */;
        if (TITAN_LIKELY(x8 < x2->sizearray)) {
            x9 = &x2->array[x8];
        } else {
            x9 = luaH_getint(x2, 1);
        }
        //if (TITAN_UNLIKELY(!ttistable(x9))) {
        //    titan_runtime_array_type_error(L, 5, LUA_TTABLE, rawtt(x9));
        //}
        Table * x10 = hvalue(x9);
        lua_Integer x11 = luaH_getn(x10);
        lua_Integer x12 /* NJ */ = x11;
        lua_Integer x13 /* start */ = 1;
        lua_Integer x14 /* finish */ = x7;
        lua_Integer x15 /* inc */ = 1;
        while ((x15 >= 0 ? x13 <= x14 : x13 >= x14)) {
            lua_Integer x16 /* k */ = x13;
            (void) x16;
            {
                lua_Unsigned x17 /* ui */ = ((lua_Unsigned)x16) - 1;
                const TValue * x18 /* arrslot */;
                if (TITAN_LIKELY(x17 < x2->sizearray)) {
                    x18 = &x2->array[x17];
                } else {
                    x18 = luaH_getint(x2, x16);
                }
                //if (TITAN_UNLIKELY(!ttistable(x18))) {
                //    titan_runtime_array_type_error(L, 7, LUA_TTABLE, rawtt(x18));
                //}
                Table * x19 = hvalue(x18);
                Table * x20 /* Bk */ = x19;
                lua_Integer x21 /* start */ = 1;
                lua_Integer x22 /* finish */ = x5;
                lua_Integer x23 /* inc */ = 1;
                while ((x23 >= 0 ? x21 <= x22 : x21 >= x22)) {
                    lua_Integer x24 /* i */ = x21;
                    (void) x24;
                    {
                        lua_Unsigned x25 /* ui */ = ((lua_Unsigned)x24) - 1;
                        const TValue * x26 /* arrslot */;
                        if (TITAN_LIKELY(x25 < x1->sizearray)) {
                            x26 = &x1->array[x25];
                        } else {
                            x26 = luaH_getint(x1, x24);
                        }
                        if (TITAN_UNLIKELY(!ttistable(x26))) {
                            titan_runtime_array_type_error(L, 9, LUA_TTABLE, rawtt(x26));
                        }
                        Table * x27 = hvalue(x26);
                        lua_Unsigned x28 /* ui */ = ((lua_Unsigned)x16) - 1;
                        const TValue * x29 /* arrslot */;
                        if (TITAN_LIKELY(x28 < x27->sizearray)) {
                            x29 = &x27->array[x28];
                        } else {
                            x29 = luaH_getint(x27, x16);
                        }
                        //if (TITAN_UNLIKELY(!ttisfloat(x29))) {
                        //    titan_runtime_array_type_error(L, 9, LUA_TNUMFLT, rawtt(x29));
                        //}
                        lua_Number x30 = fltvalue(x29);
                        lua_Number x31 /* Aik */ = x30;
                        lua_Integer x32 /* start */ = 1;
                        lua_Integer x33 /* finish */ = x12;
                        lua_Integer x34 /* inc */ = 1;
                        while ((x34 >= 0 ? x32 <= x33 : x32 >= x33)) {
                            lua_Integer x35 /* j */ = x32;
                            (void) x35;
                            {
                                lua_Unsigned x36 /* ui */ = ((lua_Unsigned)x35) - 1;
                                const TValue * x37 /* arrslot */;
                                if (TITAN_LIKELY(x36 < x20->sizearray)) {
                                    x37 = &x20->array[x36];
                                } else {
                                    x37 = luaH_getint(x20, x35);
                                }
                                //if (TITAN_UNLIKELY(!ttisfloat(x37))) {
                                //    titan_runtime_array_type_error(L, 11, LUA_TNUMFLT, rawtt(x37));
                                //}
                                lua_Number x38 = fltvalue(x37);
                                lua_Number x39 = x31 * x38;
                                lua_Number x40 = x3 + x39;
                                x3 = x40;
                            }
                            x32 = intop(+, x32, x34);
                        }
                    }
                    x21 = intop(+, x21, x23);
                }
            }
            x13 = intop(+, x13, x15);
        }
        return x3;
    }
}

static int function_matmul_lua(lua_State *L)
{
    lua_checkstack(L, 1);
    StackValue* x1 = L->ci->func;
    int x2 /* nargs */ = cast_int(L->top - (x1 + 1));
    if (TITAN_UNLIKELY(x2 != 2)) {
        titan_runtime_arity_error(L, 2, x2);
    }
    TValue* x3 = s2v(x1 + 1);
    if (TITAN_UNLIKELY(!ttistable(x3))) {
        titan_runtime_argument_type_error(L, "A", 1, LUA_TTABLE, x3);
    }
    TValue* x4 = s2v(x1 + 2);
    if (TITAN_UNLIKELY(!ttistable(x4))) {
        titan_runtime_argument_type_error(L, "B", 1, LUA_TTABLE, x4);
    }
    Table * x5 = hvalue(s2v(x1 + 1));
    Table * x6 = hvalue(s2v(x1 + 2));
    lua_Number x7 /* ret */ = function_matmul_titan(L, x5, x6);
    setfltvalue(s2v(L->top), x7);
    api_incr_top(L);
    return 1;
}

int luaopen_benchmarks_matmulsum_titan_no_checks(lua_State *L)
{
    lua_checkstack(L, 4);
    /* Allocate upvalue table */
    /* ---------------------- */
    Table * x1 = luaH_new(L);
    luaH_resizearray(L, x1, 1);
    TValue * x2 = x1->array;
    /* Initialize module var upvalues */
    /* ------------------------------ */
    /* matmul */
    CClosure* x3 = luaF_newCclosure(L, 1);
    x3->f = function_matmul_lua;
    sethvalue(L, &x3->upvalue[0], x1);
    TValue x4; setclCvalue(L, &x4, x3);
    setobj(L,  &x2[0] , &x4);
    if (iscollectable(&x4) && isblack(obj2gco(x1)) && iswhite(gcvalue(&x4))) {
        luaC_barrierback_(L, obj2gco(x1));
    }
    /* Create exports table     */
    /* ------------------------ */
    StackValue* x5 = L->top;
    sethvalue(L, s2v(x5), x1); x5++;
    L->top = x5;
    lua_createtable(L, 0, 1);
    lua_pushstring(L, "matmul");
    setobj(L, s2v(L->top), &x2[0]); api_incr_top(L);
    lua_settable(L, -3);
    return 1;
}

